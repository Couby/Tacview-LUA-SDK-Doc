[
{
	"uri": "https://couby.github.io/Tacview-LUA-SDK-Doc/fr/lua-core-interface/",
	"title": "LUA Core Interface",
	"tags": [],
	"description": "",
	"content": " Tacview 1.8.0 Lua Core Interface Dernière mise à jour : 10-06-2019 Tacview charge automatiquement tout script Lua intitulé \u0026ldquo;main.lua\u0026rdquo; trouvé dans le sous-dossier immédiatement sous :\nC:\\Program Files (x86)\\Tacview\\AddOns\\ %ProgramData%\\Tacview\\AddOns\\ %APPDATA%\\Tacview\\AddOns\\  Vous pouvez par exemple enregistrer le script principal de votre addon comme :\n%ProgramData%\\Tacview\\AddOns\\Mon add-on\\main.lua  Au début de votre script vous retrouverez typiquement l\u0026rsquo;interface lua pour laquelle le add-on a été programmé :\nTacview = require(\u0026quot;Tacview180\u0026quot;) -- Request Tacview 1.8.0 API  Ensuite vous pouvez accéder à n\u0026rsquo;importe quelle méthode du SDK comme dans l\u0026rsquo;exemple suivant :\nTacview.Log.Info(\u0026quot;Successfully exported \u0026quot;, objectCount, \u0026quot; object(s)\u0026quot;)  Selon le contexte dans lequel votre script est exécuté, vous aurez accès à des interfaces légèrement différentes. Votre script main.lua sera exécuté dans le contexte principal. Il accèdera à toutes les fonctionnalités de Tacview hormis les interfaces d\u0026rsquo;export et import.\nTandis que vos scripts import et export accèderont aux fonctionnalités coeurs comme respectivement aux interfaces d\u0026rsquo;import ou export.\nAfin d\u0026rsquo;éviter des problèmes liés au multithreading ou bien des erreurs se répercutant sur les autres add-ons, chaque add-on Lua est chargé dans sa propre machine virtuelle.\n"
},
{
	"uri": "https://couby.github.io/Tacview-LUA-SDK-Doc/fr/lua-main-interface/",
	"title": "LUA Main Interface",
	"tags": [],
	"description": "",
	"content": " Tacview 1.8.0 Lua General Interface Dernière mise à jour : 10-06-2019 Les fonctionnalités suivantes sont disponibles pour les modules Lua généraux en plus des fonctionnalités de base répertoriées dans Tacview Lua Core Interface.\nLes importateurs et exportateurs de données n\u0026rsquo;ont accès à aucune des fonctionnalités suivantes.\n"
},
{
	"uri": "https://couby.github.io/Tacview-LUA-SDK-Doc/fr/lua-core-interface/global-functions/",
	"title": "Fonctions globales",
	"tags": [],
	"description": "",
	"content": " Close() Tacview 1.7.2\nFerme l\u0026rsquo;application sans conditions.\nNOTE : cette fonction ne demande pas à l\u0026rsquo;utilisateur de sauvegarder son travail avant la fermeture.\n\r"
},
{
	"uri": "https://couby.github.io/Tacview-LUA-SDK-Doc/fr/lua-core-interface/settings/",
	"title": "Paramètres",
	"tags": [],
	"description": "",
	"content": " Cette interface permet d\u0026rsquo;accéder au paramètrage de Tacview. Si vous souhaitez sauvegarder ou charger les paramètres de votre addon, regardez AddOns.Current.Settings\nSettings.SetBoolean( settingPath, newBooleanValue ) Tacview 1.7.2\nSauvegarde un réglage Booléen sous le nom donnée.\nsettingPath peut prendre une des valeurs suivantes :\n \u0026quot;UI.View.Grid.Visible\u0026quot; \u0026ndash; Active/désactive la grille latitude/longitude \u0026quot;UI.View.HUD.Visible\u0026quot; \u0026ndash; Active/désactive le head-up-display du cockpit \u0026quot;UI.View.Overlay.Visible\u0026quot; \u0026ndash; Active/désactive la surcouche d\u0026rsquo;informations affichée sur la vue 3D \u0026quot;UI.View.Camera.Dogfight.Enabled\u0026quot; \u0026ndash; Active/désactive le mode caméra dogfight (lorsqu\u0026rsquo;en vue externe)  Settings.GetBoolean( settingFullPath ) Tacview 1.7.2\nRetourne la valeur du réglage actuel ou nil si le chemin indiqué ne pointe pas sur un réglage booléen. Regardez Settings.SetBoolean pour les valeurs possibles de settingFullPath.\nValeur retournée :\nvaleur booléenne du réglage correspondant.\n\rSettings.SetString( settingFullPath , newStringValue ) Tacview 1.7.2\nSauvegarde un réglage en chaîne de caractère sous le nom donné.\nsettingFullPath et newStringValue peuvent prendre les valeurs suivantes :\n \u0026quot;UI.View.Terrain.Mode\u0026quot; \u0026ndash; Change la manière dont le terrain est affiché dans la vue 3D \u0026quot;Empty\u0026quot; \u0026quot;Flat\u0026quot; \u0026quot;3D\u0026quot; \u0026quot;Full3D\u0026quot;\n \u0026quot;UI.View.Camera.Mode\u0026quot; \u0026ndash; Change le mode caméra\n \u0026quot;Cockpit\u0026quot;\n \u0026quot;External\u0026quot;\n \u0026quot;Satellite\u0026quot;\n \u0026quot;Free\u0026quot;\n \u0026quot;UI.View.Camera.Dogfight.Mode\u0026quot; \u0026ndash; Change le mode caméra dogfight camera (actif lorsque \u0026quot;UI.View.Camera.Mode\u0026quot; == \u0026quot;External\u0026quot; et \u0026quot;UI.View.Camera.Dogfight.Enabled\u0026quot; == true)\n \u0026quot;Centered\u0026quot;\n \u0026quot;LookAt\u0026quot;\n \u0026quot;LookForward\u0026quot;\n  Settings.GetString( settingFullPath ) Tacview 1.7.2\nRetourne la valeur du réglage actuel ou nil si le chemin indiqué ne pointe pas sur un réglage sous forme de chaîne de caractères. RegardezSettings.SetString pour les valeurs possibles de settingFullPath.\nValeur retournée :\nchaîne de caractères du réglage correspondant.\n\r"
},
{
	"uri": "https://couby.github.io/Tacview-LUA-SDK-Doc/fr/lua-core-interface/addons/",
	"title": "Add Ons",
	"tags": [],
	"description": "",
	"content": " L\u0026rsquo;interface add-ons est principalement destinée à préciser des informations concernant votre add-on.\nLes réglages de votre addon seront sauvegardés à la fermeture et rechargés à l\u0026rsquo;ouverture de Tacview.\nAddOns.Current.GetPath() Tacview 1.7.4\nRetrouve le chemin racine actuel du addon.\nC\u0026rsquo;est typiquement là où se trouve le dll ou lua de votre addon.\nCette fonction est utile pour accéder ou charger vos ressources personnalisées sans avoir à coder en dur le chemin vers celles-ci.\nValeur retournée :\nchemin du addon (i.e. C:\\ProgramData\\Tacview\\AddOns\\Tutorial 1 - Hello World - CS\\)\nou nil si non applicable (généralement pour le code Lua injecté sur un tuyau)\n\rAddOns.Current.SetTitle( addOnTitle ) Tacview 1.7.2\nDéfini un nom plus joli à montrer que le nom de répertoire du addon qui est affiché par défaut dans l\u0026rsquo;UI Tacview.\nAddOns.Current.SetVersion( textVersionNumber ) Tacview 1.7.2\nIl est recommandé de déclarer la version de votre add-on en utilisant cette fonction.\nDe cette manière, il sera plus facile pour l\u0026rsquo;utilisateur final de savoir si le moment est venu d\u0026rsquo;en télécharger une mise à jour.\nAddOns.Current.SetAuthor( authorName ) Tacview 1.7.2\nFaire savoir à tout le monde qui est l\u0026rsquo;auteur de ce magnifique add-on !\nAddOns.Current.SetNotes( textNotes ) Tacview 1.7.2\nDéfini un texte affiché dans la barre de statut Tacview lorsque le addon est sélectionné dans le menu addons.\nUne fenêtre dédiée sera disponible dans Tacview 2.\nAddOns.Current.Settings.SetBoolean( settingName , newBooleanValue ) Tacview 1.7.2\nSauvegarde un réglage booléen sous le nom donné.\nSettingName doit être une chaîne de caractère permettant d\u0026rsquo;identifier sans ambiguitée votre réglage. SettingName ne doit pas prendre la valeur \u0026ldquo;Enabled\u0026rdquo; laquelle est réservée par Tacview pour activer/désactiver le addon.\nAddOns.Current.Settings.GetBoolean( settingName , defaultBooleanValue ) Tacview 1.7.2\nRetourne la valeur courante du réglage, ou bien celle fournie par défaut si aucune valeur n\u0026rsquo;a été sauvegardée auparavant.\nValeur retournée :\nvaleur booléenne du réglage correspondant.\n\r"
},
{
	"uri": "https://couby.github.io/Tacview-LUA-SDK-Doc/fr/lua-core-interface/staticobjects/",
	"title": "StaticObjects",
	"tags": [],
	"description": "",
	"content": " StaticObjects.GetHandleByName( objectName ) Tacview 1.8.0\nRetrvoue le handle de l\u0026rsquo;objet statique à partir de son nom. Le nom de l\u0026rsquo;objet peut être défini via le tag xml  dans les fichiers kml.\nNames est sensible à la casse et peut ne pas être unique. Cette fonction retourne le projet objet trouvé correspondant. Ne pas oublier que les handles sont volatiles et peuvent ne pas être préservés à l\u0026rsquo;appel suivant du addon dans Tacview.\nValeur retournée :\nhandle de l\u0026rsquo;objet statique ou nil si aucun objet à ce nom n\u0026rsquo;est trouvé.\n\rReturn value:\nStaticObjects.SetVisible( staticObjectHandle , isVisible ) Tacview 1.8.0\nMontre ou cache l\u0026rsquo;objet indiqué. Vous pouvez utiliser StaticObjects.GetHandleByName() pour retrouver le handle de l\u0026rsquo;objet que vous souhaitez cacher/montrer.\n"
},
{
	"uri": "https://couby.github.io/Tacview-LUA-SDK-Doc/fr/lua-core-interface/log/",
	"title": "Log",
	"tags": [],
	"description": "",
	"content": " Le module log est typiquement utilisé pour afficher des messages et erreurs pouvant être utiles au diagnostique d\u0026rsquo;un problème particulier.\nTous les caractères envoyés au log sont également sauvegardés dans le fichier %TEMP%\\Tacview.log.\nS\u0026rsquo;il vous plait, utilisez le log avec sagesse et essayez de n\u0026rsquo;afficher que des messages ayant un sens pour l\u0026rsquo;utilisateur final.\nNe spammez pas le log avec des messages de développement internes, cela peut amener de la confusion pour l\u0026rsquo;utilisateur cherchant des informations plus pertinentes provenant des autres modules.\nLog.Debug(\u0026hellip;) Tacview 1.7.2\nUtilisez cette méthode pour vous aider à tracer et diagnostiquer des problèmes avec votre addon.\nNOTE : Les informations debug ne sont affichées que lorsque l\u0026rsquo;argument /Debug:On est utilisé en ligne de commande pour le lancement de Tacview.\n\rLog.Info(\u0026hellip;) Tacview 1.7.2\nCette méthode peut être utilisée pour afficher une information spécifique sur votre addon pouvant être utile à l\u0026rsquo;utilisateur final.\nNOTE : la fonction Lua print() est redirigée sur Log.Info().\n\rLog.Warning(\u0026hellip;) Tacview 1.7.2\nLes warnings peuvent être utilisés pour informer l\u0026rsquo;utilisateur de circonstances non usuelles comme des erreurs non critiques dans les données d\u0026rsquo;entrée. Les warnings seront surlignés dans la console Tacview pour attirer l\u0026rsquo;attention de l\u0026rsquo;utilisateur.\nLog.Error(\u0026hellip;) Tacview 1.7.2\nLes messages d\u0026rsquo;erreur sont typiquement utilisés pour afficher les erreurs critiques qui habituellement empêchent la poursuite des opérations.\n"
},
{
	"uri": "https://couby.github.io/Tacview-LUA-SDK-Doc/fr/lua-core-interface/ui.messagebox/",
	"title": "UI.MessageBox",
	"tags": [],
	"description": "",
	"content": " Les boîtes de dialogue peuvent afficher des notifications modales et permettre de poser des questions simples à l\u0026rsquo;utilisateur.\nIl est recommandé de ne pas utiliser des boîtes de dialogue de manière excessive parce qu\u0026rsquo;elles cassent le flow de productivité de l\u0026rsquo;utilisateur.\nLorsque c\u0026rsquo;est possible, vous pouvez utiliser le log pour afficher la plupart de vos messages et vous appuyer sur les paramètres pour choisir le comportement approprié selon les circonstances.\nUI.MessageBox.Info( textMessage ) Tacview 1.7.2\nUI.MessageBox.Error( textMessage ) Tacview 1.7.2\nAffiche une notficiation modale pour informer ou avertir l\u0026rsquo;utilisateur.\nUI.MessageBox.Question( textMessage ) Tacview 1.7.2\nAffiche une question.\nValeur retournée :\nUne des constantes suivantes :\n- UI.MessageBox.OK\n- UI.MessageBox.Cancel\n\r"
},
{
	"uri": "https://couby.github.io/Tacview-LUA-SDK-Doc/fr/lua-core-interface/math/",
	"title": "Math",
	"tags": [],
	"description": "",
	"content": " Ce module contient tous les outils nécessaires pour convertir et modifier les données typiques de la télémétrie.\nIci, nous appelons vecteurs, des tables comprenant trois composantes :\n{ x = nombre, y = nombre, z = nombre, }  Math.Angle.Subtract( leftAngle , rightAngle ) Tacview 1.7.2\nSoustraction entre deux angles en radian.\nValeur retournée :\nDifférence entre leftAngle et rightAngle.\nLe résultat est normalisé entre [-pi, +pi].\n\rMath.Units.FeetToMeters( value ) Tacview 1.8.0\nConvertis les distances en pieds en mètres.\nMath.Units.NauticalMilesToMeters( value ) Tacview 1.8.0\nConvertis les miles nautiques en mètres.\nMath.Vector.LongitudeLatitudeToCartesian( {longitude = number , latitude = number , altitude = number} ) Tacview 1.7.2\nConvertis des coordonnées sphériques terrestres en coordonnées cartésiennes. Il est possible de directement donner une transformée d\u0026rsquo;objet à cette fonction, voir Telemetry.GetCurrentTransform.\nLongitude et latitude sont en radian. Altitude est en mètres.\nValeur retournée :\nUn vecteur représentant une position cartésienne dans l\u0026rsquo;espace terrien global.\n\rMath.Vector.CartesianToLongitudeLatitude( {x = number , y = number , z = number} ) Tacview 1.7.5\nConvertis des coordonnées cartésiennes en coordonnées sphériques terrestres.\nValeur retournée :\nUne table contenant { longitude = \u0026hellip; , latitude = \u0026hellip; , altitude = \u0026hellip;}\nLongitude et latitude sont en radian.\nAltitude est en mètres.\n\rMath.Vector.BearingRangeAltitudeToLongitudeLatitude( referenceLongitude , referenceLatitude , bearing , range , altitude ) Tacview 1.8.0\nRetrouve les longitude, latitude et altitude relatives à un point de référence donné.\n Longitude et latitude sont exprimés en radian. Le Bearing est donné en degré par rapport au Nord vrai. La distance est donnée en mètres. L\u0026rsquo;altitude est exprimée en mètres.  Valeur retournée :\nPosition du point cible sous le format {longitude = nombre , latitude = nombre , altitude = nombre}\n\rMath.Vector.Add( vector1 , vector2 ) Tacview 1.7.2\nSomme de deux vecteurs 3D.\nValeur retournée :\nUn vecteur représentant la somme de vector1 et vector2.\n\rMath.Vector.Subtract( vector1 , vector2 ) Tacview 1.7.2\nDifférence entre deux veteurs 3D.\nValeur retournée :\nUn vecteur représentant la différence entre vector1 et vector2.\n\rMath.Vector.Multiply( factor , vector ) Tacview 1.7.5\nMultiplie un vecteur désigné par une valeur scalaire.\nValeur retournée :\nLa vector mis à l\u0026rsquo;échelle.\n\rMath.Vector.Normalize( vector ) Tacview 1.7.2\nNormalise un vecteur donné.\nValeur retournée :\nvector normalisé.\nCette fonction est sûre, aussi un vecteur nul indique que le vecteur est nul.\n\rMath.Vector.GetLength( vector ) \u0026ndash; Tacview 1.8.0 Retrouve la longeur d\u0026rsquo;un vecteur donné.\nMath.Vector.GetDistance( pt1 , pt2 ) \u0026ndash; Tacview 1.8.0 Retrouve la distance entre deux points 3D cartésiens donnés.\nMath.Vector.GetDistanceOnEarth( longitude1 , latitude1 , longitude2 , latitude2 , altitude ) \u0026ndash; Tacview 1.8.0 Retrouve la distance entre les coordonnées spécifiées sur terre à l\u0026rsquo;altitude donnée au-dessus du niveau de la mer.\nMath.Vector.AngleBetween( vector1 , vector2 ) Tacview 1.7.2\nCalcule l\u0026rsquo;angle entre deux vecteurs normalisés. NE PAS oublier de normaliser les vecteurs avant l\u0026rsquo;appel GetAngle!\n\rNOTE : Si vous souhaitez un calcul quadran exact, vous devriez plutôt utiliser la fonction à trois paramètres.\n\rValeur retournée :\nAngle en radian entre les deux vecteurs donnés.\nCela correspond à ArcCos( DotProduct( vector1, vector2 ) )\n\rMath.Vector.AngleBetween( vector , referenceVector1 , referenceVector2 ) Tacview 1.7.2\nCalcule l\u0026rsquo;angle entre deux vecteurs normalisés. NE PAS oublier de normaliser les vecteurs avant l\u0026rsquo;appel GetAngle!\n\rContrairement à AngleBetween( vector1 , vector2 ), cette fonction donne le quadran exact.\nValeur retournée :\nAngle en radian entre les deux vecteurs donnés.\nCela correspond à ArcTan( DotProduct( vector, referenceVector1 ), DotProduct( vector, referenceVector2 ) )\n\rMath.Vector.LocalToGlobal( objectTransform , localCoordinates ) Tacview 1.7.2\nConvertis le point donné des coordonnées d\u0026rsquo;un objet local en coordonnées cartésiennes terrestres.\nVous pouvez directement passer en argument de cette fonction, la table objectTransform provenant de Telemetry.GetCurrentTransform() dans laquelle localCoordinates est un vecteur.\nobjectTransform = { -- Si xyz ne sont pas précisés, ils seront calculés à partir des informations longitude, latitude, et altitude. x = cartesianPositionX, -- mètres y = cartesianPositionY, -- mètres z = cartesianPositionZ, -- mètres -- Si longitude ou latitude n'est pas précisé, ils sont calculés à partir du xyz. longitude = sphericalLongitude, -- radian latitude = sphericalLatitude, -- radian altitude = absoluteAltitude, -- (mètres) requis seulement si xyz n'est pas spécifié roll = objectRoll, -- radian pitch = objectPitch, -- radian yaw = objectYaw, -- radian }  Valeur retournée :\ncoordonnées comme vecteur dans l\u0026rsquo;espace global cartésien terrestre.\nretourne nil dans le cas où la quantité d\u0026rsquo;information fournie n\u0026rsquo;est pas suffisante.\n\r"
},
{
	"uri": "https://couby.github.io/Tacview-LUA-SDK-Doc/fr/lua-core-interface/context/",
	"title": "Contexte",
	"tags": [],
	"description": "",
	"content": " Comprend toutes les informations relatives à la représentation de la télémétrie à l\u0026rsquo;écran. NOTE : voir Lua Main Interface pour des fonctions additionnelles.\n\rContext.GetAbsoluteTime() Tacview 1.7.5\nRetrouve le temps courant de la télémétrie en seconde depuis le 01-01-1970 (ce paramètre est utile pour échanger avec le module Télémétrie).\nContext.SetAbsoluteTime( absoluteTime ) Tacview 1.7.6\nRègle le temps courant de la télémétrie pour le rejeu des données en secondes depuis le 01-01-1970.\nNOTE : NE PAS forcer le temps à chaque frame, en particulier durant l\u0026rsquo;enregistrement temps réel d\u0026rsquo;une télémétrie.\nCela entrerait en conflit avec la mise à jour du temps interne à Tacview, ce qui amènerait des sauts dans la vue 3D.\n\rSi vous souhaitez synchroniser le temps Tacview avec un outils externe, vous devriez ne le faire que lorsqu\u0026rsquo;il y a une différence de temps significative entre les deux outils :\n-- Synchronisation du temps Tacview seulement lorsque la différence de temps avec l'outils externe est supérieure à une seconde if math.abs(Context.GetAbsoluteTime() - externalToolTime) \u0026gt; 1.0 then Context.SetAbsoluteTime(externalToolTime) end  "
},
{
	"uri": "https://couby.github.io/Tacview-LUA-SDK-Doc/fr/lua-core-interface/telemetry/",
	"title": "Télémétrie",
	"tags": [],
	"description": "",
	"content": " Ce module est le coeur de Tacview.\nUtilisez le gestionnaire de télémétrie pour lire et écrire des données pour tout objet dynamique.\nTelemetry.BeginningOfTime Tacview 1.7.5\nTelemetry.EndOfTime Tacview 1.7.5\nConstantes utilisées pour spécifier deux marqueurs de temps spéciaux.\nBeginningOfTime = -3.4028234663853e+38 EndOfTime = 3.4028234663853e+38  BeginningOfTime est typiquement utilisé pour créer des objets intemporels comme les waypoints ou les bâtiments. EndOfTime est utile par exemple pour identifier les objets encore vivants en fin d\u0026rsquo;enregistrement de télémétrie.\nSi vous avec besoin de connaître l\u0026rsquo;horodatage des débuts et fin d\u0026rsquo;enregistrement de la télémétrie, regarder la fonction Telemetry.GetDataTimeRange()\nTelemetry.InvalidPropertyIndex Tacview 1.7.5\nConstante utilisée pour détecter des propriétés invalides.\nTelemetry.Tags Tacview 1.7.3\nÉnumération des bits utilisés pour définir les types d\u0026rsquo;objets.\n -- Domain Telemetry.Tags.Air Telemetry.Tags.Ground Telemetry.Tags.Sea Telemetry.Tags.Weapon Telemetry.Tags.Sensor Telemetry.Tags.Navaid Telemetry.Tags.Misc -- Attributes Telemetry.Tags.Static Telemetry.Tags.Heavy Telemetry.Tags.Medium Telemetry.Tags.Light Telemetry.Tags.Minor -- Types basiques Telemetry.Tags.FixedWing Telemetry.Tags.Rotorcraft Telemetry.Tags.Armor Telemetry.Tags.AntiAircraft Telemetry.Tags.Vehicle Telemetry.Tags.Watercraft Telemetry.Tags.Human Telemetry.Tags.Biologic Telemetry.Tags.Missile Telemetry.Tags.Rocket Telemetry.Tags.Bomb Telemetry.Tags.Torpedo Telemetry.Tags.Projectile Telemetry.Tags.Beam Telemetry.Tags.Decoy Telemetry.Tags.Building Telemetry.Tags.Bullseye Telemetry.Tags.Waypoint -- Specific Type Telemetry.Tags.Tank Telemetry.Tags.Warship Telemetry.Tags.AircraftCarrier Telemetry.Tags.Submarine Telemetry.Tags.Infantry Telemetry.Tags.Parachutist Telemetry.Tags.Shell Telemetry.Tags.Bullet Telemetry.Tags.Flare Telemetry.Tags.Chaff Telemetry.Tags.SmokeGrenade Telemetry.Tags.Aerodrome Telemetry.Tags.Container Telemetry.Tags.Shrapnel Telemetry.Tags.Explosion  Cas d\u0026rsquo;usage pour identifier si un objet est de type avion :\nlocal objectTags = Tacview.Telemetry.GetCurrentTags( objectHandle ) if (Tacview.Telemetry.AllGivenTagsActive(objectTags, Tacview.Telemetry.Tags.FixedWing)) then this_is_a_plane; end  Telemetry.AllGivenTagsActive( objectTags , activeTagsCombination ) Tacview 1.8.0\nTelemetry.AnyGivenTagActive( objectTags , activeTagsCombination ) Tacview 1.8.0\nAides pour savoir si tout ou partie de combinaisons de tags correspond aux tags d\u0026rsquo;un objet donné. Vous retrouvez les tags actuels d\u0026rsquo;un objets (qui définissent le type de l\u0026rsquo;objet) avec la fonction Telemetry.GetCurrentTags.\nReturn value:\ntrue or false depending on the match\n\rTelemetry.Property Tacview 1.7.6\nListe des noms des propriétés supportées nativement par Tacview.\n -- Propriétés de textes Telemetry.Property.Text.Callsign Telemetry.Property.Text.Event Telemetry.Property.Text.Name -- Propriétés numériques Telemetry.Property.Numeric.Disabled Telemetry.Property.Numeric.EngagementRange  Telemetry.Clear() Tacview 1.7.2\nPurge toutes les données de télémétrie actuellement chargées en mémoire.\nCette fonction ne prévient pas l\u0026rsquo;utilisateur et ne lui donne pas la possibilité de sauvegarder des données.\nCette fonction n\u0026rsquo;interrompt ni n\u0026rsquo;arrête aucun enregistrement en cours. Il purge simplement toutes les données enregistrées jusque-là.\nTelemetry.Load( fileName ) Tacview 1.8.0\nCette fonction fusionne le fichier de données indiqué avec celui déjà en mémoire. Appelez Telemetry.Clear() avant de charger de nouvelles données si vous ne souhaitez pas fusionner.\nValeur retournée :\ntrue si le fichier indiqué a correctement été chargé\n\rTelemetry.IsEmpty() Tacview 1.7.6\nIndique si aucune télémétrie n\u0026rsquo;est actuellement chargée en mémoire.\nCela inclut les données intemporelles.\nTelemetry.IsLikeEmpty() Tacview 1.7.6\nIndique si aucune télémétrie significative n\u0026rsquo;est actuellement chargée en mémoire.\nPar exemple, si aucune donnée ou seulement des données intemporelles sont chargées, cette fonction renvoie true.\nSinon, il retourne false.\nTelemetry.GetDataTimeRange() Tacview 1.7.6\nRécupère l\u0026rsquo;étendue des données de télémétrie actuellement chargées en mémoire.\nCeci exclut les échantillons intemporels tels que la position des bullseyes par exemple.\nValeur retournée :\n{\nbeginTime, \u0026ndash; premier échantillon de temps absolu\nendTime \u0026ndash; dernier échantillon de temps absolu\n}\n\rTelemetry.GetCurrentObjectHandle( objectId ) Tacview 1.7.2\nRécupère le descripteur de l\u0026rsquo;objet - objectHandle - spécifié à l\u0026rsquo;heure de mise à jour actuelle.\nS\u0026rsquo;il existe plusieurs objets ayant le même identifiant (par exemple, un joueur ayant été créés plusieurs fois dans le même aéronef au cours d\u0026rsquo;une même session), le gestionnaire de télémétrie renvoie l\u0026rsquo;objet le plus approprié pour la période actuelle.\nContrairement aux ID, les descripteurs d\u0026rsquo;objets identifient de manière unique chaque objet actuellement chargé en mémoire.\nValeur retournée :\nobjectHandle (integer)\n\rTelemetry.GetCurrentOrCreateObjectHandle( objectId ) Tacview 1.7.5\nRécupère le descripteur de l\u0026rsquo;objet - objectHandle - spécifié à l\u0026rsquo;heure de mise à jour actuelle.\nSi l\u0026rsquo;identifiant d\u0026rsquo;objet donné n\u0026rsquo;est pas trouvé, un nouvel objet sera créé à la mise à jour actuelle avec l\u0026rsquo;identifiant donné.\nContrairement aux ID, les descripteurs d\u0026rsquo;objets identifient de manière unique chaque objet actuellement chargé en mémoire.\nValeur retournée :\nobjectHandle (integer)\n\rTelemetry.GetOrCreateObjectHandle( objectId , absoluteTime ) Tacview 1.7.5\nRécupère le descripteur de l\u0026rsquo;objet spécifié à l\u0026rsquo;heure spécifiée.\nSi l\u0026rsquo;identifiant d\u0026rsquo;objet donné n\u0026rsquo;est pas trouvé, un nouvel objet sera créé à l\u0026rsquo;heure spécifiée avec l\u0026rsquo;identifiant donné.\nContrairement aux ID, les descripteurs d\u0026rsquo;objets identifient de manière unique chaque objet actuellement chargé en mémoire.\nPour créer un objet intemporel comme un waypoint, vous pouvez utiliser les éléments suivants : local newObjectHandle = Tacview.Telemetry.GetOrCreateObjectHandle( objectId , Tacview.Telemetry.BeginningOfTime )\nValeur retournée :\nobjectHandle (integer)\n\rTelemetry.GetCurrentTags( objectHandle ) Tacview 1.7.3\nReturn given object tags as a bit field. Renvoie le tag de l\u0026rsquo;objet indiqué sous forme de champ de bits.\nValeur retournée :\nChaque bit du nombre entier renvoyé correspond à un tag spécifique. La combinaison de ces balises définit le type d\u0026rsquo;objet actuel. Le type d\u0026rsquo;objet peut évoluer dans le temps et être affiné en fonction de la télémétrie disponible à ce moment.\n\rTelemetry.GetCurrentShortName( objectHandle ) Tacview 1.7.2\nRenvoie le nom abrégé de l\u0026rsquo;objet donné à la mise à jour actuelle.\nValeur retournée :\nTexte qui correspond généralement au code OTAN ou à toute autre désignation courte appropriée pour l\u0026rsquo;objet.\n\rTelemetry.GetTransform( objectHandle , absoluteTime ) Tacview 1.7.5\nTelemetry.GetCurrentTransform( objectHandle ) Tacview 1.7.2\nRenvoie la position / rotation de l\u0026rsquo;objet donnée à la mise à jour actuelle ou à l\u0026rsquo;heure spécifiée.\nCertains objets (généralement les obus) peuvent ne pas avoir toutes les informations disponibles.\nPar exemple, les informations de rotation peuvent ne pas être disponibles pour tous les aéronefs.\nLes coordonnées natives correspondent aux coordonnées d\u0026rsquo;origine dans le simulateur de vol source (généralement pour BMS et DCS).\nValeur retournée :\n\r ObjectTransform = { time = sample_absolute_time, -- (secondes) L'heure absolue effective de cet échantillon peut être différente de l'heure de mise à jour actuelle si l'objet n'existe pas encore, ou plus... x = cartesianPositionX, -- (mètres) position cartésienne (TOUJOURS DISPONIBLE) y = cartesianPositionY, -- (mètres) position cartésienne (TOUJOURS DISPONIBLE) z = cartesianPositionZ, -- (mètres) position cartésienne (TOUJOURS DISPONIBLE) longitude = sphericalLongitude, -- (radian) position sphérique (TOUJOURS DISPONIBLE) latitude = sphericalLatitude, -- (radian) position sphérique (TOUJOURS DISPONIBLE) altitude = absoluteAltitude, -- (mètres) position sphérique (TOUJOURS DISPONIBLE) roll = objectRoll, -- (radian) axe de rotation en roulis (si rotationIsValid == true) pitch = objectPitch, -- (radian) axe de rotation en tangage (sif rotationIsValid == true) yaw = objectYaw, -- (radian) axe de rotation en lacet (si rotationIsValid == true) u = nativePositionX, -- (mètres) coordonnée native x (si nativeCoordinatesAreValid == true) v = nativePositionY, -- (mètres) coordonnée native y (si nativeCoordinatesAreValid == true) heading = nativeHeadingToNorth, -- (radian) Heading dans le système de coordonnées natif (si nativeCoordinatesAreValid == true \u0026amp; rotationIsValid == true) rotationIsValid = boolean, -- Définie à true si les informations de rotation sont valides (sinon, les données peuvent être émulées) nativeCoordinatesAreValid = boolean, -- Définie à true si les coordonnées natives sont valides (sinon u, v et heading sont mis à zéro) }  Valeur retournée :\nvalue , validity\nvalidity est défini sur false si la valeur ne s\u0026rsquo;applique pas vraiment pour le moment donné (généralement si l\u0026rsquo;objet n\u0026rsquo;existe pas à ce moment-là) événement lorsque la validité est définie sur false, la valeur est valide et utilisable (cela simplifie le code client)\n\rTelemetry.GetVerticalGForce( objectHandle , absoluteTime ) Tacview 1.8.0\nTelemetry.GetCurrentVerticalGForce( objectHandle ) Tacview 1.7.3\nRetourne le facteur de charge vertical s\u0026rsquo;il est disponible à l\u0026rsquo;heure actuelle.\nLe g-Force vertical est le g-Force qui s\u0026rsquo;applique au pilote et à son avion. C\u0026rsquo;est celui généralement affiché en cabine.\nSi le facteur de charge vertical a été enregistré, Tacview renverra l\u0026rsquo;échantillon interpolé. Si le facteur de charge vertical n\u0026rsquo;a pas été enregistré, mais que les données de rotation sont disponibles, Tacview calculera le facteur de charge vertical.\nValeur retournée :\nVertical G-Force si disponible.\nnil quand il n\u0026rsquo;y a pas suffisamment de données disponibles (ou l\u0026rsquo;objet n\u0026rsquo;existe pas à ce moment).\n\rTelemetry.GetAbsoluteGForce( objectHandle , absoluteTime ) Tacview 1.8.0\nTelemetry.GetCurrentAbsoluteGForce( objectHandle ) Tacview 1.8.0\nRetourne le facteur de charge absolu de l\u0026rsquo;objet s\u0026rsquo;il est disponible à l\u0026rsquo;heure actuelle.\nLe g-Force absolu est l\u0026rsquo;accélération de l\u0026rsquo;objet divisé par G. Il est indépendant de l\u0026rsquo;orientation de l\u0026rsquo;objet ou de sa trajectoire.\nValeur retournée :\nAbsolute g-Force si disponible.\nnil quand il n\u0026rsquo;y a pas suffisamment de données disponibles (ou l\u0026rsquo;objet n\u0026rsquo;existe pas à ce moment).\n\rTelemetry.GetGlobalNumericPropertyIndex( propertyName , autoCreate ) Tacview 1.7.6\nTelemetry.GetGlobalTextPropertyIndex( propertyName , autoCreate ) Tacview 1.7.6\nRécupérer une propriété pour l\u0026rsquo;objet global (0).\nSi la propriété n\u0026rsquo;existe pas encore :\n Si autoCreate est à true, la propriété sera créée et son index renvoyé. Si autoCreate est sur false, Telemetry.InvalidPropertyIndex sera renvoyé.  Pour optimiser la charge CPU et mémoire, les propriétés numériques et textuelles sont séparées dans le gestionnaire de télémétrie.\nATTENTION : Les propriétés numériques et textuelles étant séparées, les index des échantillons numériques et textuels peuvent se chevaucher et ne peuvent pas être mélangés.\n\rTelemetry.GetObjectsNumericPropertyIndex( propertyName , autoCreate ) Tacview 1.7.5\nTelemetry.GetObjectsTextPropertyIndex( propertyName , autoCreate ) Tacview 1.7.5\nRécupérez un index de propriété pour tout ce qui n\u0026rsquo;est pas l\u0026rsquo;objet global.\nL\u0026rsquo;index renvoyé est le même pour tous les objets.\nSi la propriété n\u0026rsquo;existe pas encore:\n Si autoCreate est à true, la propriété sera créée et son index renvoyé. Si autoCreate est sur false, Telemetry.InvalidPropertyIndex sera renvoyé.  Pour optimiser la charge CPU et mémoire, les propriétés numériques et textuelles sont séparées dans le gestionnaire de télémétrie.\nATTENTION : Les propriétés numériques et textuelles étant séparées, les index des échantillons numériques et textuels peuvent se chevaucher et ne peuvent pas être mélangés.\n\rTelemetry.GetNumericSample( objectHandle , absoluteTime , propertyIndex ) Tacview 1.7.5\nTelemetry.GetTextSample( objectHandle , absoluteTime , propertyIndex ) Tacview 1.7.5\nRécupère la valeur numérique ou textuelle de la propriété à un moment donné.\nValeur retournée :\nvalue , validity\nvalidité est définie sur false si la valeur ne s\u0026rsquo;applique pas vraiment pour le moment donné (généralement si l\u0026rsquo;objet n\u0026rsquo;existe pas à ce moment-là) événement lorsque la validité est définie sur false, la valeur est valide et utilisable (cela simplifie le code client)\n\rTelemetry.SetNumericSample( objectHandle , absoluteTime , propertyIndex , value ) Tacview 1.7.5\nTelemetry.SetTextSample( objectHandle , absoluteTime , propertyIndex , value ) Tacview 1.7.5\nDéfinir ou redéfinir une valeur numérique ou une propriété de texte donnée à un moment donné.\nVous pouvez définir absoluteTime sur Tacview.Telemetry.BeginningOfTime pour déclarer les propriétés des objets intemporels tels que les waypoints.\nTelemetry.GetNumericSampleCount( objectHandle , propertyIndex ) Tacview 1.8.0\nTelemetry.GetTextSampleCount( objectHandle , propertyIndex ) Tacview 1.8.0\nRécupère le nombre d\u0026rsquo;échantillons actuellement chargés en mémoire pour l\u0026rsquo;objet spécifié. Cette fonction est généralement utilisée pour énumérer les échantillons d\u0026rsquo;objets.\nTelemetry.GetNumericSampleFromIndex( objectHandle , sampleIndex , propertyIndex ) Tacview 1.8.0\nTelemetry.GetTextSampleFromIndex( objectHandle , sampleIndex , propertyIndex ) Tacview 1.8.0\nRécupérer une donnée de télémétrie d\u0026rsquo;objet spécifique à partir de son index. SampleIndex commence à 0 et se termine au compte-1.\nReturn value:\nsampleValue , sampleTime , validity\nRetourne nil si invalide\n\rTelemetry.SetTransform( objectHandle , absoluteTime , transform ) Tacview 1.7.5\nDéfinir ou redéfinir la position et la rotation de l\u0026rsquo;objet à l\u0026rsquo;heure indiquée.\nabsoluteTime est un nombre à virgule flottante de 64 bits représentant le nombre de secondes écoulées jusqu\u0026rsquo;au 1970-01-01T00: 00: 00Z\nLes angles injectés (y compris la longitude et la latitude) DOIVENT être normalisés entre ]-pi, +pi]\nSi vous ne le faites pas, certaines formules pourraient produire des résultats non définis.\nPour des raisons de performances, les angles récupérés par le gestionnaire de télémétrie NE sont PAS toujours normalisés entre ]-pi, +pi]\nN\u0026rsquo;oubliez pas de normaliser les angles avant d\u0026rsquo;afficher ensuite le texte à l\u0026rsquo;utilisateur final !\n\u0026ndash; les membres non spécifiés seront définis sur la valeur interpolée des échantillons précédent et suivant.\ntransform { -- position sphérique f64 longitude; -- (radian) position sphérique (+ est vers l'est) f64 latitude; -- (radian) position sphérique (+ est vers le nord) f32 altitude; -- (mètres) position sphérique -- Rotation f32 roll; -- (radian) axe de rotation en roulis f32 pitch; -- (radian) axe de rotation en tangage f32 yaw; -- (radian) axe de rotation en lacet -- Les coordonnées natives, utilisées principalement pour obtenir un calcul précis de la distance et de la vitesse pour les simulateurs de monde plat. f32 u; -- (mètres) coordonnée native x f32 v; -- (mètres) coordonnée native y f32 heading; -- (radian) Heading dans le système de coordonnées natif };  Telemetry.GetTransformTimeRange( objectHandle ) Tacview 1.8.0\nRetrouve les temps du premier et du dernier échantillon transform de l\u0026rsquo;objet spécifié. Cette fonction est typiquement utilisé pour énumérer les échantillons sur la période de vie effective. Retourne nil si l\u0026rsquo;objet n\u0026rsquo;a pas d\u0026rsquo;échantillon transform disponible. Notez que Telemetry.BeginningOfTime peut être retournée si l\u0026rsquo;objet n\u0026rsquo;est pas temporel comme le Bullseye.\nValeur retournée :\n{\nfirstTransformSampleTime, \u0026ndash; temps absolu du premier échantillon transform existant\nlastTransformSampleTime \u0026ndash; temps absolu du dernier échantillon transform existant\n}\n\rTelemetry.GetLifeTime( objectHandle ) Tacview 1.7.6\nRenvoie l\u0026rsquo;heure absolue de la première apparition de l\u0026rsquo;objet et l\u0026rsquo;heure de sa disparition, le cas échéant. A la différence de GetObjectDataTimeRange(), cette fonction peut retourner une plage de temps plus grande pouvant aller jusqu\u0026rsquo;à Telemetry.EndOfTime si l\u0026rsquo;objet n\u0026rsquo;a jamais été détruit ou retiré du champs de bataille. Utilisez préférentiellement GetTransformTimeRange() si vous souhaitez itérer sur les échantillons de télémétrie de l\u0026rsquo;objet via un compteur de temps.\nValeur retournée :\nlifeTimeBegin, lifeTimeEnd\n\rSi l\u0026rsquo;objet existe depuis le début des temps (par exemple, un bullseye), son lifeTimeBegin est Telemetry.BeginningOfTime.\nSi l\u0026rsquo;objet n\u0026rsquo;a jamais été détruit ni supprimé du champ de bataille, lifeTimeEnd est Telemetry.EndOfTime.\nTelemetry.SetLifeTimeEnd( objectHandle , absoluteTime ) Tacview 1.7.5\nDéfinit la fin de vie de l\u0026rsquo;objet spécifié.\nGénéralement utilisé pour spécifier quand un objet a été détruit ou a été retiré du champ de bataille.\nTelemetry.RemoveNumericSample( objectHandle , absoluteTime , propertyIndex ) Tacview 1.8.0\nTelemetry.RemoveNumericSampleFromIndex( objectHandle , sampleIndex , propertyIndex ) Tacview 1.8.0\nTelemetry.RemoveTextSample( objectHandle , absoluteTime , propertyIndex ) Tacview 1.8.0\nTelemetry.RemoveTextSampleFromIndex( objectHandle , sampleIndex , propertyIndex ) Tacview 1.8.0\nSupprimer la valeur de l\u0026rsquo;échantillon à l\u0026rsquo;heure ou à l\u0026rsquo;index spécifié.\nReturn value:\ntrue si l\u0026rsquo;opération de suppression s\u0026rsquo;est bien passée\nfalse si l\u0026rsquo;un des paramètres est obsolète (en raison d\u0026rsquo;un changement de télémétrie en temps réel, par exemple)\n\rTelemetry.DeleteObject( objectHandle ) Tacview 1.7.5\nSupprime l\u0026rsquo;objet spécifié du gestionnaire de télémétrie.\nCette opération est sécurisée: le descripteur - handle - correspondant restera valide jusqu\u0026rsquo;à la prochaine purge effective (généralement lors du chargement d\u0026rsquo;un nouveau fichier de télémétrie) afin que les autres modules ne se bloquent pas s\u0026rsquo;ils tentent de référencer l\u0026rsquo;objet par la suite.\nCependant, toutes les données liées à cet objet seront libérées.\nTelemetry.GetObjectCount() Tacview 1.7.6\nRécupère le nombre total d\u0026rsquo;objets actuellement actifs dans le gestionnaire de télémétrie.\nGénéralement utilisé pour énumérer tous les objets.\nTelemetry.GetObjectHandleByIndex( index ) Tacview 1.7.6\nRécupère un objet par son index. NOTE : L\u0026rsquo;index va de 0 à GetObjectCount() - 1.\n\rValeur retournée :\nLe descripteur - handle - de l\u0026rsquo;objet ou nil si l\u0026rsquo;index est hors de portée.\n\rTelemetry.GetObjectId( objectHandle ) Tacview 1.7.6\nRécupère l\u0026rsquo;identifiant d\u0026rsquo;objet donné.\nAttention, les identifiants d\u0026rsquo;objet peuvent être recyclés et ne peuvent pas identifier des objets de manière unique.\nPour cette raison, évitez de les utiliser, à moins que ce soit pour l\u0026rsquo;injection de télémétrie (création d\u0026rsquo;événement) ou l\u0026rsquo;exportation.\n"
},
{
	"uri": "https://couby.github.io/Tacview-LUA-SDK-Doc/fr/lua-core-interface/terrain/",
	"title": "Terrain",
	"tags": [],
	"description": "",
	"content": " Les fonctions suivantes peuvent être utilisées pour personnaliser le terrain et récupérer des informations à son sujet.\nTerrain.GetElevation( longitude , latitude ) Tacview 1.7.5\nRécupère une altitude donnée en mètre. Longitude et latitude sont en radian.\n"
},
{
	"uri": "https://couby.github.io/Tacview-LUA-SDK-Doc/fr/lua-main-interface/ui/",
	"title": "UI",
	"tags": [],
	"description": "",
	"content": " Fonctions générales pour manipuler l\u0026rsquo;interface utilisateur et l\u0026rsquo;aspect de Tacview.\nUI.EnterFullScreen() Tacview 1.7.2\nUI.ExitFullScreen() Tacview 1.7.2\nEntrer/quitter le mode plein écran.\nEn mode plein écran, Tacview affiche uniquement la vue 3D dans une fenêtre sans bordure.\nCela peut être utile lors d\u0026rsquo;un débriefing en ligne, afin que l\u0026rsquo;utilisateur puisse se concentrer pleinement sur les objets affichés dans la vue 3D.\nL\u0026rsquo;utilisateur peut basculer manuellement entre le mode plein écran et le mode fenêtré en appuyant sur [ALT] + [ENTER].\nIl est également possible de quitter le mode plein écran en appuyant sur [Esc].\nUI.EnterReadMode( [borderless] ) Tacview 1.7.2\nUI.ExitReadMode() Tacview 1.7.2\nEntrer/sortir du mode lecture.\nEn mode lecture, Tacview affiche uniquement la vue 3D (les outils et les menus sont masqués).\nborderless est un paramètre booléen facultatif qui peut être défini sur true si vous souhaitez également masquer la bordure de la fenêtre Tacview.\nCette fonction consiste principalement à intégrer la fenêtre Tacview dans une autre application lorsqu\u0026rsquo;elle est associée à UI.SetWindowParent().\nUI.SetWindowParent( parentWindowhandle ) Tacview 1.7.2\nAttachez la fenêtre principale de Tacview à une autre fenêtre d\u0026rsquo;application.\nGénéralement utilisé avec UI.EnterReadMode(true) et UI.SetWindowPosition() pour afficher Tacview dans une autre application.\nAppelez SetWindowParent(nil) pour détacher la fenêtre principale de Tacview de votre application.\nUI.SetWindowPosition( x , y [, width , height] ) Tacview 1.7.2\nModifiez la position et la taille de la fenêtre principale de Tacview lorsque width et height sont fournies. La position est spécifiée pour le coin supérieur/gauche de la fenêtre sur le bureau ou dans la fenêtre parente.\nUI.SetWindowSize( width , height ) Tacview 1.7.2\nChange la taille de la fenêtre principale de Tacview.\nwidth et height doievent être \u0026gt; 0.\nUI.GetWindowHandle() Tacview 1.7.5\nRenvoie le handle de la fenêtre principale de Tacview.\nVous pouvez utiliser cette fonction pour créer des fenêtres enfants ou des boîtes de dialogue pour votre addon.\nN\u0026rsquo;UTILISEZ PAS cette fonction pour modifier manuellement la taille, la position ou le parent de la fenêtre de Tacview. Dans ce cas, utilisez les fonctions dédiées, qui font plus que simplement appeler le système d\u0026rsquo;exploitation.\nValeur retournée :\nhandle de la fenêtre principale de Tacview.\nCe handle peut être nil si Tacview est exécuté en mode silent en ligne de commande.\n\r"
},
{
	"uri": "https://couby.github.io/Tacview-LUA-SDK-Doc/fr/lua-main-interface/ui.menus/",
	"title": "UI.Menus",
	"tags": [],
	"description": "",
	"content": " L’interface Menu est utile pour créer et insérer des commandes et des options dans les menus de Tacview.\nTous les nouveaux menus seront ajoutés au menu des addons.\nTacview supprimera automatiquement les éléments de menu d\u0026rsquo;un addon qui est déchargé.\nUI.Menus.AddMenu( parentMenuId , textLabel ) Tacview 1.7.2\nCrée et insère un menu dans le menu Tacview.\nVous pouvez spécifier l\u0026rsquo;identifiant d\u0026rsquo;un menu parent ou vous pouvez utiliser nil pour insérer votre menu dans le menu principal des add-ons Tacview.\nValeur retournée :\nun id de menu (entier) qui peut être utilisé plus tard pour insérer des sous-éléments ou pour supprimer le menu.\n\rUI.Menus.AddSeparator( parentMenuId ) Tacview 1.8.0\nAjoute un séparateur dans le menu indiqué. Utilisez des séparateurs pour grouper des options et commandes, rendant ainsi vos menus plus intuitifs pour vos utilisateurs.\nUI.Menus.AddCommand( parentMenuId , textLabel , function ) Tacview 1.7.2\nInsére une commande dans le menu donné.\nVous pouvez spécifier l\u0026rsquo;identifiant d\u0026rsquo;un menu parent ou vous pouvez utiliser nil pour insérer votre menu dans le menu principal des add-ons Tacview.\nfunction sera appelé chaque fois que cette commande de menu aura été cliquée.\nValeur retournée :\nun id de menu (entier) qui peut être utilisé plus tard pour insérer des sous-éléments ou pour supprimer le menu.\n\rUI.Menus.AddOption( parentMenuId , textLabel , optionBoolean , function ) Tacview 1.7.2\nInsére une commande avec une coche dans le menu donné.\nSi optionBoolean est true, une coche apparaîtra après le libellé de la commande.\nVous pouvez spécifier l\u0026rsquo;identifiant d\u0026rsquo;un menu parent ou vous pouvez utiliser nil pour insérer votre menu dans le menu principal des add-ons Tacview.\nfunction sera appelé chaque fois que cette option de menu aura été cliquée.\nReturn value:\nid de Manu qui peut être utilisé plus tard pour changer la valeur de l\u0026rsquo;option au moyen de UI.Menus.SetOption().\n\rUI.Menus.SetOption( menuId , optionBoolean ) Tacview 1.7.2\nChanger la valeur d\u0026rsquo;une option de menu. Si optionBoolean est true, une coche apparaîtra à côté du libellé de la commande correspondante.\n"
},
{
	"uri": "https://couby.github.io/Tacview-LUA-SDK-Doc/fr/lua-main-interface/ui.messagebox/",
	"title": "UI.MessageBox",
	"tags": [],
	"description": "",
	"content": " Les boîtes de message peuvent être utilisées pour afficher des notifications et poser des questions simple à l\u0026rsquo;utilisateur. Il est recommandé de ne pas abuser de ce type d\u0026rsquo;interface au risque de casser le flux de productivité de l\u0026rsquo;utilisateur. Lorsque c\u0026rsquo;est possible, vous pouvez utiliser le log pour afficher la plupart des messages et vous appuyer sur settings pour choisir des comportements appropriés dépendants des circonstances.\nUI.MessageBox.GetSaveFileName( options ) Tacview 1.8.0\nDemande à l\u0026rsquo;utilisateur sous quel nom de fichier il/elle souhaite sauvegarder un fichier.\noptions = { defaultFileExtension = defaultFileExtension, \u0026ndash; exclu le \u0026lsquo;.\u0026rsquo;, par exemple \u0026ldquo;csv\u0026rdquo; fileName = defaultFileNameToSave, \u0026ndash; (OPTIONNEL) chemin complet ou nom de fichier par défaut pour le fichier à sauvegarder\nfileTypeList = -- Liste des types acceptés pour la sauvegarde (habituellement un item du type usuel) { { extensions, description } -- Type(s) de fichier(s) et description {\u0026quot;*.jpg;*.png\u0026quot;, \u0026quot;Picture\u0026quot;} }  }\nValeur retournée :\nchemin complet du nom de fichier à sauvegarder\nnil si l\u0026rsquo;utilisateur a annulé l\u0026rsquo;opération\n\rExemple:\nlocal options =\n{\ndefaultFileExtension = \u0026ldquo;csv\u0026rdquo;,\nfileTypeList =\n{\n{ \u0026ldquo;.csv\u0026rdquo; , \u0026ldquo;Comma-separated values\u0026rdquo; }\n{ \u0026ldquo;.xml\u0026rdquo; , \u0026ldquo;Extensible Markup Language\u0026rdquo; }\n{ \u0026ldquo;.json;.js\u0026rdquo; , \u0026ldquo;JavaScript Object Notation\u0026rdquo; }\n}\n}\n\rUI.MessageBox.GetFolderName( options ) Tacview 1.8.0\nInvite l\u0026rsquo;utilisateur à sélectionner un répertoire et retrouve le chemin complet du répertoire sélectionné.\noptions = { folderName = defaultFolderNameToSelect, \u0026ndash; (OPTIONNEL) chemin complet du répertoire à sélectionner par défaut canCreateNewFolder = boolean, \u0026ndash; (OPTIONNEL) régler sur true pour permettre à l\u0026rsquo;utilisateur de créer de nouveaux répertoires }\nValeur retournée :\nchemin complet du nom de répertoire\nnil si l\u0026rsquo;utilisateur a annulé l\u0026rsquo;opération\n\rExemple:\nlocal options =\n{\nfolderName = \u0026ldquo;C:/Downloads/\u0026ldquo;,\ncanCreateNewFolder = true,\n}\n\r"
},
{
	"uri": "https://couby.github.io/Tacview-LUA-SDK-Doc/fr/lua-main-interface/ui.renderer/",
	"title": "UI.Renderer",
	"tags": [],
	"description": "",
	"content": " Le rendu est généralement utilisé pour afficher des objets dans la vue 3D principale.\nNOTE: Les fonctions de dessin peuvent être appelées uniquement pendant les événements de dessin.\n\rVoir Events.* pour savoir comment enregistrer des callbacks de dessin.\nUI.Renderer.GetWidth() Tacview 1.7.2\nRécupérer la largeur de rendu en pixels ou nil en dehors d\u0026rsquo;un événement de dessin.\nUI.Renderer.GetHeight() Tacview 1.7.2\nRécupère la hauteur du moteur de rendu en pixels ou nil en dehors d\u0026rsquo;un événement de dessin.\nUI.Renderer.LoadTexture( texturePath [, wrapRepeat [, compressed] ] ) Tacview 1.7.3\nUI.Renderer.UnloadTexture( textureHandle ) Tacview 1.7.3\nwrapRepeat = doit être défini sur true si vous souhaitez que la texture soit répétée (par défaut = true)\ncompressed = doit être défini sur true si vous souhaitez que la texture soit compressée (recommandé) (par défaut = true)\nChargez un fichier png ou jpg et compilez-le en tant que texture.\nSeuls les formats 24 bits et 32 bits sont pris en charge.\nLe format 32 bits peut être utilisé pour dessiner des textures translucides.\nLes textures sont directement utilisées par UI.Renderer.CreateRenderState\nLes textures sont utilisées indirectement (dans les états de rendu) par UI.Renderer.DrawObjectVertexArray et UI.Renderer.DrawUIVertexArray.\nLes textures sont automatiquement déchargées lorsque le module complémentaire est libéré.\nValeur retournée :\nLe handle de texture ou nil si le fichier n\u0026rsquo;a pas été trouvé ou invalide.\n\rUI.Renderer.CreateVertexArray( vertexArray ) Tacview 1.7.2\nUI.Renderer.ReleaseVertexArray( vertexArrayHandle ) Tacview 1.7.2\nLes tableaux de vertex sont une liste de points 3D utilisés pour afficher des bandes de triangle, qui à leur tour représentent des objets 3D à l\u0026rsquo;écran.\nLes matrices de vertex sont automatiquement libérées lorsque l\u0026rsquo;addon est déchargé.\nTypiquement:\n Vous devez appeler une fois (par objet 3D) UI.Renderer.CreateVertexArray() pour préparer votre tableau de sommets. Ensuite, dans votre rappel Events.DrawOpaqueObjects(), vous pouvez utiliser le descripteur renvoyé par CreateVertexArray() pour dessiner votre objet à l\u0026rsquo;aide de UI.Renderer.DrawVertexArray(). Chaque fois que le tableau de vertex n\u0026rsquo;est plus requis, vous pouvez libérer la ressource associée en appelant UI.Renderer.ReleaseVertexArray().\nvertexArray = { x, y, z, \u0026hellip; }\n  Valeur retournée :\nhandle (entier) du tableau compilé ou nil si le tableau n\u0026rsquo;est pas valide.\n\rUI.Renderer.CreateTextureCoordinateArray( textureCoordinateArray ) Tacview 1.7.3\nUI.Renderer.ReleaseTextureCoordinateArray( textureCoordinateArrayHandle ) Tacview 1.7.3\nLes tableaux de coordonnées de texture sont une liste de coordonnées 2D utilisées pour texturer des bandes de triangle.\nIls sont automatiquement libérés lorsque l\u0026rsquo;addon est déchargé.\ntextureCoordinateArray = { u, u, ... }  Valeur retournée :\nhandle (entier) du tableau compilé ou nil si le tableau n\u0026rsquo;est pas valide.\n\rUI.Renderer.CreateRenderState( renderState ) Tacview 1.7.2\nUI.Renderer.ReleaseRenderState( renderStateHandle ) Tacview 1.7.2\nL\u0026rsquo;état de dessin décrit les constantes qui seront utilisées pour un ou plusieurs appels à dessin.\nGénéralement utilisé pour spécifier une couleur unique pour un modèle 3D complet, ainsi qu\u0026rsquo;une liste de textures utilisées lors des opérations de dessin.\nVous pouvez utiliser à tout moment UI.Renderer.ReleaseRenderState() pour libérer la ressource associée à un état de dessin précédemment compilé.\nLes états de dessin sont automatiquement libérés lorsque l\u0026rsquo;addon est déchargé.\nrenderState = { -- Couleur OPTIONNELLE (blanc opaque par défaut) -- Rouge opaque : 0xff0000ff -- Vert opaque : 0xff00ff00 -- Bleu opaque : 0xffff0000 [color = 32_bit_rgba_color_code,] -- Texture OPTIONNELLE chargée avec UI.Renderer.LoadTexture() [texture = textureHandle,] -- Mode de fusion OPTIONNELLE (pour les phases de rendu transparentes) [ blendMode = Tacview.UI.Renderer.BlendMode.Normal Tacview.UI.Renderer.BlendMode.Additive ] }  Valeur retournée :\nhandle (entier) du tableau compilé ou nil si le tableau n\u0026rsquo;est pas valide.\n\rUI.Renderer.DrawObjectVertexArray( transform , renderStateHandle , vertexArrayHandle ) Tacview 1.7.2\nUI.Renderer.DrawObjectVertexArray( transform , renderStateHandle , vertexArrayHandle [, textureCoordinateArrayHandle] ) Tacview 1.7.3\nrenderStateHandle est un entier précédemment renvoyé par UI.Renderer.CreateRanderState()\nvertexArrayHandle est un entier précédemment renvoyé par UI.Renderer.CreateVertexArray()\ntextureCoordinateArrayHandle est un entier optionnel précédemment renvoyé par UI.Renderer.CreateTextureCoordinateArray()\ntransform = { -- Si la position cartésienne xyz dans l'espace global terrestre n'est pas fournie, elle sera calculée en fonction de la position sphérique (longitude, latitude, altitude). x = nombre, y = nombre, z = nombre, -- Si la position sphérique n'est pas fournie, elle sera calculée en fonction de la position cartésienne xyz. longitude = radian, latitude = radian, altitude = meters, -- Infor de rotation optionnelle roll = radian, pitch = radian, yaw = radian, -- Echelle optionnelle scale = nombre }  Dessinez le modèle 3D donné (à partir d\u0026rsquo;un précédent appel à UI.Renderer.CreateVertexArray) en utilisant l\u0026rsquo;état donné (à partir d\u0026rsquo;un précédent appel à UI.Renderer.CreateRenderState) à l\u0026rsquo;emplacement/la rotation/l\u0026rsquo;échelle donné(e) dans la vue 3D.\nLes tableaux state et vertex doivent être créés uniquement UNE FOIS.\nNE re-déclarez PAS l\u0026rsquo;état et/ou le tableau de vertex à chaque appel de dessin, cela entraînerait une fuite des ressources.\nUI.Renderer.DrawUIVertexArray( transform , renderStateHandle , vertexArrayHandle ) Tacview 1.7.2\nUI.Renderer.DrawUIVertexArray( transform , renderStateHandle , vertexArrayHandle [, textureCoordinateArrayHandle] ) Tacview 1.7.3\nrenderStateHandle est un entier précédemment renvoyé par UI.Renderer.CreateRenderState()\nvertexArrayHandle est un entier précédemment renvoyé par UI.Renderer.CreateVertexArray()\ntextureCoordinateArrayHandle est un entier optionnel précédemment renvoyé par UI.Renderer.CreateTextureCoordinateArray()\ntransform = { -- Coordonnées d'écran obligatoires x = nombre, y = nombre, z = nombre, -- 0 par défaut -- Orientation optionnelle roll = radian, pitch = radian, yaw = radian, -- Echelle uniforme optionnelle scale = number -- Echelle non uniforme optionnelle -- Tacview 1.8.0 scaleX = number scaleY = number }  Lors du passage de l\u0026rsquo;interface utilisateur, les coordonnées 2D sont comme en suivant :\nUI.Renderer.GetHeight() ^ |transform.Y | | | transform.x +------------------\u0026gt; UI.Renderer.GetWidth() 0,0  Dessine le modèle 2D / 3D donné (à partir d\u0026rsquo;un précédent appel à UI.Renderer.CreateVertexArray) en utilisant l\u0026rsquo;état donné (à partir d\u0026rsquo;un précédent appel à UI.Renderer.CreateRenderState()) à la position donnée/rotation/échelle par dessus la vue 3D.\nLes tableaux state et vertex doivent être créés uniquement UNE FOIS.\nNE re-déclarez PAS l\u0026rsquo;état et/ou le tableau de vertex à chaque appel de dessin, cela entraînerait une fuite des ressources.\nUI.Renderer.DrawOpaqueObject( objectHandle , transform [, alpha ] ) Tacview 1.7.2\nUI.Renderer.DrawTransparentObject( objectHandle , transform [, alpha ] ) Tacview 1.7.2\nFonction de haut niveau pour dessiner les parties opaques ou transparentes de l\u0026rsquo;objet de télémétrie correspondant dans la vue 3D.\nCes fonctions utiliseront automatiquement la forme et la couleur de l\u0026rsquo;objet actuel pour afficher correctement le modèle 3D dans la vue 3D.\nUI.Renderer.DrawOpaqueObject() est généralement appelé dans les rappels Events.DrawOpaqueObjects pour dessiner le corps de l\u0026rsquo;objet principal.\nUI.Renderer.DrawTransparentObject () est généralement appelé dans les rappels Events.DrawTransparentObjects pour dessiner les parties transparentes restantes des objets (par exemple, les aptitudes correctes).\ntransform = { -- Si la position sphérique n'est pas fournie, Tacview utilisera la position cartésienne xyz dans l'espace global terrestre x = nombre, y = nombre, z = nombre, -- La position sphérique sera utilisée en priorité pour rendre l'objet longitude = radian, latitude = radian, altitude = meters, -- Info de rotation optionnelle roll = radian, pitch = radian, yaw = radian, -- Echelle optionnelle scale = nombre } Vous pouvez redimensionner l'objet ou définir l'échelle sur -1 pour une mise à l'échelle automatique (en fonction des paramètres utilisateur) Vous pouvez forcer la transparence de l'objet ou définir alpha sur -1 pour le mode automatique (selon le statut mort/vivant)  UI.Renderer.Print( transform , renderStateHandle , text ) Tacview 1.7.3\nImprimer le texte donné aux coordonnées x, y correspondantes.\nDevrait être utilisé uniquement lors d\u0026rsquo;opérations d\u0026rsquo;interface utilisateur transparente en 2D.\nVous pouvez définir renderState.blendMode sur Tacview.UI.Renderer.BlendMode.Additive pour afficher le texte de style HUD.\ntransform = { -- Si la position cartésienne xyz dans l'espace global terrestre n'est pas fournie, elle sera calculée en fonction de la position sphérique (longitude, latitude, altitude). x = nombre, y = nombre, -- Echelle optionnelle scale = nombre }  UI.Renderer.ContextMenu.RegisterListener( function ) Tacview 1.7.6\nUtilisez cette fonction pour enregistrer un rappel et ajouter des options au menu contextuel que Tacview affichera par clic droit dans la vue 3D.\nJuste avant d\u0026rsquo;afficher le menu contextuel de la vue 3D, Tacview appellera la fonction suivante pour vous permettre d\u0026rsquo;ajouter une option personnalisée :\n function( contextMenuId , objectHandle ) -- **contextMenuId** (entier) : Id du menu contextuel dans lequel vous pouvez ajouter des options. -- **objectHandle** (entier) : objet associé au menu contextuel (0 si aucun objet n'est lié au menu)  Utilisez les fonctions UI.Menus avec parentMenuId défini sur contextMenuID pour ajouter vos propres options au menu contextuel en fonction de l\u0026rsquo;objet sélectionné.\nLe menu contextuel est volatile et sera automatiquement détruit dès sa fermeture par l\u0026rsquo;utilisateur.\nChaque fois que votre rappel est appelé, vos options seront ajoutées à un tout nouveau menu.\n"
},
{
	"uri": "https://couby.github.io/Tacview-LUA-SDK-Doc/fr/lua-main-interface/events/",
	"title": "Evénements",
	"tags": [],
	"description": "",
	"content": " Vous pouvez enregistrer des rappels pour différents types d’événements dans Tacview.\nEvents.Update.RegisterListener( function ) Tacview 1.7.2\nUne fois par image, Tacview appellera votre fonction qui doit correspondre à la signature suivante :\nUpdate(dt, absoluteTime)\n dt est le nombre de secondes écoulées dans la vie réelle depuis le dernier Update() absoluteTime est la durée actuelle de la télémesure en secondes depuis le 01/01/1970 (ce paramètre est utile pour parler avec le module de télémétrie)  Events.DrawOpaqueObjects.RegisterListener( function ) Tacview 1.7.2\nEvents.DrawTransparentObjects.RegisterListener( function ) Tacview 1.7.2\nUne fois par image, Tacview appellera votre fonction pour dessiner des objets 3D dans la vue 3D.\nIl existe une passe pour les modèles 3D opaques et une passe pour les modèles transparents.\nVoir UI.Renderer.DrawObjectVertexArray() et UI.Renderer.DrawOpaqueObject)() pour dessiner des objets dans le monde 3D.\nEvents.DrawOpaqueUI.RegisterListener( function ) Tacview 1.7.2\nEvents.DrawTransparentUI.RegisterListener( function ) Tacview 1.7.2\nUne fois par image, Tacview appelle votre fonction pour dessiner une interface utilisateur de premier plan transparente 2D au-dessus de la vue 3D.\nVotre fonction ne recevra aucun paramètre.\nVoir UI.Renderer.DrawUIVertexArray() pour dessiner votre UI au-dessus de la vue 3D.\n"
},
{
	"uri": "https://couby.github.io/Tacview-LUA-SDK-Doc/fr/lua-main-interface/context/",
	"title": "Context",
	"tags": [],
	"description": "",
	"content": " Ce module contient toutes les informations relatives à la représentation de télémétrie à l\u0026rsquo;écran.\nNOTE : Voir Lua Core Interface pour des fonctions supplémentaires.\n\rContext.GetSelectedObject( objectIndex ) Tacview 1.7.2\nRécupère le handle de l\u0026rsquo;un des objets sélectionnés.\nobjectIndex peut être 0 pour l\u0026rsquo;objet primaire ou 1 pour l\u0026rsquo;objet secondaire.\nIl est actuellement possible de sélectionner deux objets en même temps.\nContext.SetSelectedObject( objectIndex , objectHandle ) Tacview 1.7.2\nChoisissez quel objet est actuellement sélectionné.\nobjectIndex peut être 0 pour l\u0026rsquo;objet primaire ou 1 pour l\u0026rsquo;objet secondaire.\nL\u0026rsquo;utilisateur sélectionne généralement un ou plusieurs objets pour modifier le point de vue de la caméra ou pour définir un contexte spécifique pour certains outils.\nPour obtenir un descripteur - handle - d\u0026rsquo;objet à partir de son identifiant de télémétrie, utilisez la fonction Telemetry.GetObjectHandle(id).\nContext.GetActiveObjectList() Tacview 1.7.3\nRécupérez les descripteurs - handles - de tous les objets actuellement actifs (vivants) à l\u0026rsquo;heure de lecture actuelle.\nLa table renvoyée contient les descripteurs sans ordre spécifique.\nRetourne une table vide si aucun objet n\u0026rsquo;est actuellement actif.\nValeur retournée :\n{ objectHandle1 , objectHandle2 , \u0026hellip; }\n\r"
},
{
	"uri": "https://couby.github.io/Tacview-LUA-SDK-Doc/fr/lua-main-interface/context.camera/",
	"title": "Context.Camera",
	"tags": [],
	"description": "",
	"content": " La caméra est utilisée pour définir le point de vue de l\u0026rsquo;utilisateur dans la fenêtre 3D de Tacview.\nContext.Camera.GetMode() Tacview 1.7.2\nRetourne le mode de caméra actuel.\nValeur retournée :\nCamera.Cockpit\nCamera.External\nCamera.Satellite\nCamera.Free\n\rContext.Camera.SetRotation( roll , pitch , yaw ) Tacview 1.8.0\nOriente la caméra.\nroll: en radian, positif pour une inclinaison vers la droite pitch: en radian, positif en montée yaw: en radian, positif pour un virage vers la droite  Lorsque \u0026ldquo;UI.View.Camera.Dogfight.Mode\u0026rdquo; == \u0026ldquo;LookAt\u0026rdquo; et \u0026ldquo;UI.View.Camera.Dogfight.Enabled\u0026rdquo; == true la rotation produit un décalage relatif à l\u0026rsquo;objet cible. En d\u0026rsquo;autres mots, la rotation de (0,0,0) pointera la camera vers l\u0026rsquo;objet secondaire.\nSi vous voulez regarder sur la droite de l\u0026rsquo;objet cible, réglez simplement le yaw de la caméra sur +45 degrés:\nTacview.Context.Camera.SetExternalViewRotation( 0 , 0 , math.rad(45) )  NOTE: Lorsque le mode caméra est sélectionné, la rotation est généralement mise à zéro.\nPour cette raison, vous devez changer la rotation APRES le passage dans le mode caméra de votre choix.\n\rContext.Camera.SetOffset( offsetData ) Tacview 1.7.2\nDécalage temporaire de la position et de la rotation de la caméra.\nLe décalage est automatiquement réinitialisé à chaque nouvelle image lorsqu\u0026rsquo;il n\u0026rsquo;est pas remplacé par un addon.\nLes composants suivants peuvent être spécifiés, ils sont tous facultatifs :\noffsetData = { lateral = meters_positive_to_the_right , longitudinal = meters_positive_forward , vertical = meters_positive_up , roll = radian , pitch = radian , yaw = radian , }  Context.Camera.SetFieldOfView( radian ) Tacview 1.7.2\nModifiez le champ de vision vertical de la caméra pour une image.\nLe champ de vision est automatiquement réinitialisé à chaque nouvelle image lorsqu\u0026rsquo;il n\u0026rsquo;est pas remplacé par un addon.\nLe champ de vision par défaut est 60 degrés.\nNOTE : Le champ de vision doit être défini en radian.\n\r"
},
{
	"uri": "https://couby.github.io/Tacview-LUA-SDK-Doc/fr/lua-main-interface/context.playback/",
	"title": "Context.Playback",
	"tags": [],
	"description": "",
	"content": " Fonctions pour contrôler la lecture des données de télémétrie chargées.\nContext.Playback.Play() Tacview 1.7.6\nContext.Playback.Pause() Tacview 1.7.6\nReprendre / mettre en pause la lecture.\nContext.Playback.IsPlaying() Tacview 1.7.6\nRetourne false si la lecture est actuellement en pause.\n"
},
{
	"uri": "https://couby.github.io/Tacview-LUA-SDK-Doc/fr/credits/",
	"title": "Crédits",
	"tags": [],
	"description": "",
	"content": "Copyright © 2006-2019 Raia Software Inc. Tous droits réservés.\nAuteur de l\u0026rsquo;application Tacview : Frantz \u0026ldquo;Vyrtuoz\u0026rdquo; Raia\nDocumentation LUA SDK par Frantz \u0026ldquo;Vyrtuoz\u0026rdquo; Raia\nTraduction française de la documentation LUA SDK par Frédéric \u0026ldquo;Couby Stark\u0026rdquo; Coubard\n"
},
{
	"uri": "https://couby.github.io/Tacview-LUA-SDK-Doc/fr/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " C’est le moment de mettre la main sur le tout nouveau SDK en Lua ! La version 1.7.2 est un grand pas en avant pour la communauté : J’ai enfin terminé l’intégration du langage Lua 5.3.4. Créez vos propres addons a l’aide de l’interface de programmation dédiée. Pour étendre les fonctionnalités existantes ou en développer des nouvelles !\nPour créer un addon il suffit de :\n Créer un dossier portant le nom de votre addon dans C:\\ProgramData\\Tacview\\AddOns\n Créer un fichier nommé \u0026ldquo;main.lua\u0026rdquo; dans ce dossier (il sera automatiquement chargé au démarrage de Tacview). Cela devrait ressembler à C:\\ProgramData\\Tacview\\AddOns\\My Addon\\main.lua Référencer la toute dernière API de Tacview a l’aide d’un simple : local Tacview = require(\u0026quot;Tacview172\u0026quot;) Il ne reste plus qu’à utiliser les nombreuses fonctionnalités documentées dans C:\\Program Files (x86)\\Tacview\\AddOns\\Tacview Lua * Interface.txt Vous pouvez même utiliser LuaSocket 3.0 qui a été intégré dans Tacview est qui est prêt à remplir tous vos besoins en termes de connectivité ! Il suffit de l’habituel code : socket = require(\u0026quot;socket\u0026quot;)  Il s’agit de la première itération, et bien que l’API actuelle soit relativement limitée, ses fonctionnalités vont s’étoffer rapidement au fil des mises a jours et en fonction de vos requêtes. Faites-moi simplement savoir de quoi vous avez besoin, et je ferais de mon mieux pour ajouter de nouvelles fonctions afin que vous puissiez développer l’addon de vos rêves.\nVous trouverez plusieurs exemples en Lua dans C:\\Program Files (x86)\\Tacview\\AddOns\\\nLe plus notable étant « Landing Signal Officer » (officier d’appontage), actuellement en développement, qui affichera bientôt une camera LSO lorsque l’on passe en vue cockpit sur un porte avion. Prochainement, il calculera automatiquement les scores de tentatives d’atterrissage.\nVoyez les la liste des changements ci-dessous pour plus de détail sur les nombreuses améliorations et corrections.\n"
},
{
	"uri": "https://couby.github.io/Tacview-LUA-SDK-Doc/fr/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://couby.github.io/Tacview-LUA-SDK-Doc/fr/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]